// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var $$Array     = require("bs-platform/lib/js/array.js");
var Caml_obj    = require("bs-platform/lib/js/caml_obj.js");
var Caml_array  = require("bs-platform/lib/js/caml_array.js");
var Caml_int32  = require("bs-platform/lib/js/caml_int32.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

var rawInput = "2\t8\t8\t5\t4\t2\t3\t1\t5\t5\t1\t2\t15\t13\t5\t14";

var parsedInput = $$Array.map(Caml_format.caml_int_of_string, rawInput.split("\t"));

function addIndex(blocks) {
  return $$Array.mapi((function (index, block) {
                return /* tuple */[
                        index,
                        block
                      ];
              }), blocks);
}

function getMaxBlock(blocks) {
  return $$Array.fold_left((function (param, param$1) {
                var nextValue = param$1[1];
                var maxValue = param[1];
                if (maxValue >= nextValue) {
                  return /* tuple */[
                          param[0],
                          maxValue
                        ];
                } else {
                  return /* tuple */[
                          param$1[0],
                          nextValue
                        ];
                }
              }), Caml_array.caml_array_get(addIndex(blocks), 0), addIndex(blocks));
}

function incrementBlock(index, blocks) {
  var index$1 = index;
  var blocks$1 = $$Array.copy(blocks);
  Caml_array.caml_array_set(blocks$1, index$1, Caml_array.caml_array_get(blocks$1, index$1) + 1 | 0);
  return blocks$1;
}

function getNextIteration(blocks) {
  var match = getMaxBlock(blocks);
  var maxIndex = match[0];
  var copy = $$Array.copy(blocks);
  Caml_array.caml_array_set(copy, maxIndex, 0);
  var numBlocks = blocks.length;
  var _blocks = copy;
  var _currentBlock = Caml_int32.mod_(maxIndex + 1 | 0, numBlocks);
  var _counter = match[1];
  while(true) {
    var counter = _counter;
    var currentBlock = _currentBlock;
    var blocks$1 = _blocks;
    if (counter) {
      _counter = counter - 1 | 0;
      _currentBlock = Caml_int32.mod_(currentBlock + 1 | 0, numBlocks);
      _blocks = incrementBlock(currentBlock, blocks$1);
      continue ;
      
    } else {
      return blocks$1;
    }
  };
}

function findRepeatedBlock(_seen, _currentIteration) {
  while(true) {
    var currentIteration = _currentIteration;
    var seen = _seen;
    if (List.mem(getNextIteration(currentIteration), seen)) {
      return getNextIteration(currentIteration);
    } else {
      _currentIteration = getNextIteration(currentIteration);
      _seen = List.append(seen, /* :: */[
            getNextIteration(currentIteration),
            /* [] */0
          ]);
      continue ;
      
    }
  };
}

function countLoopSize(repeatStart) {
  var iter = function (currentIteration) {
    if (Caml_obj.caml_equal(currentIteration, repeatStart)) {
      return 1;
    } else {
      return 1 + iter(getNextIteration(currentIteration)) | 0;
    }
  };
  return iter(getNextIteration(repeatStart));
}

console.log(countLoopSize(findRepeatedBlock(/* :: */[
              parsedInput,
              /* [] */0
            ], parsedInput)));

exports.rawInput          = rawInput;
exports.parsedInput       = parsedInput;
exports.addIndex          = addIndex;
exports.getMaxBlock       = getMaxBlock;
exports.incrementBlock    = incrementBlock;
exports.getNextIteration  = getNextIteration;
exports.findRepeatedBlock = findRepeatedBlock;
exports.countLoopSize     = countLoopSize;
/* parsedInput Not a pure module */
